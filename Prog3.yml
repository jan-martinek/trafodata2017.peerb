name: "Skriptování 3: Detaily javascriptu"
goals: |
  V závěrečné lekci si potvrdíme již trochu zažité konvence jazyka Javascript, zobecníme naučené věci a vyzkoušíme si pár interaktivních skriptů.
reading: |
  Tato lekce se nejprve vrací se k základům Javascriptu. V tomto kurzu se snažíme jeho syntaxi především „odkoukat“ z ukázek kódu, ale zpětně je dobré se podívat, čím jsme si prošli a získané znalosti si potvrdit. 

  Proto zde najdete několik příkladů, které jsou uvozeny dlouhým textem, ale nejsou příliš komplexní. Při čtení byste už díky předchozím lekcím měli tušit, co to které slovo označuje — pokud vědět nebudete, využijte opět vyhledávač. **Mnohé úkoly mají povahu hádanky: cílem je najít v kódu odpověď na poměrně krátkou otázku a během toho hledání si upevnit znalost struktury kódu.**
  
  > **Obecné doporučení:** nesnažte se pochopit psaný text celý najednou, ale zkoušejte si průběžně, co vás napadne (v konzoli nebo v místech pro zpracování úkolů).

  ### Syntaxe javascriptu
  
  **Kód se skládá z příkazů, které jsou vždy odděleny středníkem.** Běžně příkazy píšeme pro přehlednost na samostatné řádky, ale není to nutné.
  
      var result = findSomething();
      console.log(result);
  
  Podstatné kousky kódu jsou:
  
  - složené závorky `{` `}` vymezují bloky kódu
  - operátor přiřazení `=` vkládá obsah do proměnné
  - matematické operátory `+` `-` `*` (násobení) `/` (dělení) `%` (zbytek po dělení)
  - relační (porovnávací) operátory `==` `!=` `>` `>=` `<` `<=` `===` `!==`
  - logické operátory `&&` (logické A) `||` (logické NEBO) pro skládání podmínek
  - klíčová slova jako např. `var` `function` `true` `false` `while` `for` `if` `else` či `new`
  - a parametry funkcí, které uzavíráme při definici i při volání do závorek `var f = function(parametr)` `f(10)`
  
  Krom toho jsou podstatné **přímé zápisy hodnot (literály)**: čísla píšeme přímo (`6`, `3.14`), řetězce uzavíráme do jednoduchých (`'řetězec'`) nebo klasických uvozovek (`"řetězec"`). Regulární výrazy, o nichž se dozvíme více v další lekci, jsou ohraničeny speciálním znakem, nejčastěji se používá lomítko: `/^regex$/`.
  
  **Názvy proměnných** mohou obsahovat písmena, číslice a podtržítko, ale nesmí začínat číslicí a nesmí být klíčovým slovem. Názvy proměnných tedy mohou být `color`, `turtleSize` nebo `_snowFlakePart6`. Každou proměnou musíme nejprve vytvořit — při tom používáme klíčové slovo `var`:

      var color = 'red';
  
  Při práci s objekty (uloženými v proměnných) přistupujeme k jejich vlastnostem a metodám pomocí tečky (tedy např. `turtle.forward(50)` nebo `turtle.penDown`). Můžeme využít hranato-závorkového zápisu `turtle["penDown"]` — to se hodí tehdy, když máme název vlastnosti v proměnné: 

      var prop = 'penDown'; 
      var value = turtle[prop];
  
  Pro ujištění v detailech si můžete dohledat referenci Javascriptu — jako obvykle se dá najít poměrně hezký [cheatsheet](https://www.cheatography.com/kelt/cheat-sheets/learning-javascript/) anebo můžete využít nějaký český zdroj, např. tento již poměrně zastaralý, ale [velmi stručný přehled](http://www.fi.muni.cz/~xhejtman/P005/jssyntax.html) (sekce *Příkazy*, *Řízení chodu programu* a *Funkce*).
rubrics:
  - "Pokud jste objevili nějakou chybu, upřesněte, kde se chyby nachází. Pokuste se problematiku osvětlit tak, aby to autorovi/autorce pomohlo."
preface:
---
bloom: understand
comments: 15
input: turtle
questions: |
  ### Jak číst kód?
  
  Kód byste neměli číst od začátku do konce — už kvůli tomu, že většinou se od začátku do konce neprovádí.
  
  Definice funkcí procházet nemusíte: jejich účel by měl být srozumitelný i bez toho, že si přečtete jejich kód. Nejprve si tedy projděte kód, který není uvnitř funkcí. Tak poznáte základní kostru programu.
  
  Např. v minulé lekci jsme se setkali s kódem, který generuje vločku. Ten má následující části:
    
  1. definice proměnných, které se používají v celém skriptu
  2. definice funkce `snowflakePart()`, která kreslí část vločky
  3. definice funkce `setup()`, která 
    - nastavuje vlastnosti plátna
    - vytváří želvu
    - definuje metodu `snowflake()`, která kreslí vločku mimo jiné pomocí volání `snowflakePart()`
  4. funkce funkce `draw()`, která obstarává animaci
  5. pomocná funkce `repeat()`
    
  Nejprve stačí, když si všimnete této struktury a následujete běh kódu — nikoli dle definic, ale dle volání funkcí:
  
  1. Nejprve se zavolá funkce `setup()`, to víte díky předchozím úkolům.
  2. Ta nejprve vydefinuje funkci `snowflake()` a následně ji hned zavolá.
  3. Tak se mrknete, jak postupuje `snowflake()` — nejprve vydefinuje funkci `drawPart` a tu pak šestkrát provede pomocí volání `repeat()`.
  4. A teď vidíte, že uvnitř `drawPart()` se dějí tři hlavní věci:
    - první volání `snowflakePart(-1)` — se záporným parametrem 
    - druhé volání `snowflakePart(1)`
    - a natočení želvy `turtle.right(360/6)`
  5. Teď víte, že se něco uvnitř funkce `snowflakePart()` volá dvanáctkrát — a už zbývá jen prozkoumat, co se to tam děje a jak to ovlivňuje parametr `mirror`.
  
  Oproti čtení od začátku do konce tedy mnohem lépe sledujete průběh programu: ale nemusíte číst funkci `snowflakePart()` dvanáctkrát :-) Zároveň je na začátek skriptu vytažená důležitá funkce, pomocí níž ovlivníte vzhled vločky nejvíce.
  
  ### Zadání
  
  Projděte následující podobně strukturovaný kód (je převzatý z jedné z úloh z předchozí lekce a zjednodušený). Do pole pro komentář 1) **vypište názvy metod, které jsou v kódu definované** a **následně popište vlastními slovy skript** — nikoli od prvního do posledního řádku, ale dle výše popsané logiky. (Pokud by vás vyděsila složená podmínka s operátorem `||`, podívejte se na úkol č. 3.)
prefill: |
  var turtle, run, size = toy.measure();

  var goCarefully = function() {
    turtle.forward(10);
    
    if (
      turtle.getX() < 50 || 
      turtle.getY() < 50 ||
      turtle.getX() > size.w - 50 ||
      turtle.getY() > size.h - 50
    ) {
      turnInShock();
    }  
  };

  var turnInShock = function() {
    turtle.back(20);
    turtle.right(p.random(85,270));
  };

  p.setup = function() {
    p.createCanvas(size.w, size.h);
    p.angleMode(p.DEGREES);

    turtle = new Turtle(p);
    repeat(goCarefully, 1000);
    run = turtle.getRun();
  };

  p.draw = function() {
    p.background(200);
    run.animate(10);
  };

  function repeat(fn, n) {
    var a = Array.apply(null, Array(n)).map(
      function (_, i) {return i;}
    ).forEach(fn);
  }
rubrics:
  - checklist: ''
    items:
      - Názvy všech definovaných metod jsou vypsané.
      - Skript je správně popsán.
      - Skript je popsán dle toho, jak funguje, nikoli „od prvního do posledního řádku“.
---
bloom: understand
input: turtle
comments: 10
questions: |
  ### Jak psát kód?
  
  Stejně jako není dobré kód sekvenčně číst, není dobré jej sekvenčně psát. Při tvorbě postupu (algoritmu) postupujte podle logických celků, jejichž splnění vede ke splnění úkolu.
  
  Například můžete chtít, aby želva nakreslila sluníčko. Sluníčko můžete popsat jako kruh obklopený čarami, které vycházejí ze středu kruhu. Není to úplně přesný popis, ale máte představu, kterou můžete zrealizovat na základě základních funkcí, které želva umí: chodit tam a zpět a zatáčet vpravo a vlevo.
  
  Pokud byste šli a začali rovnou psát první příkaz „turtle.forward()“, nejspíše byste nedošli daleko, než by želva začala dělat nesmysly a bylo by těžké zjistit proč. Proto je lepší algoritmus rozdělit postupně do snadno proveditelných částí.
  
  ### Nastavení výchozího stavu
  
  Nejprve si nastavíte prostředí — v našem případě nastavíte plátno a umístíte želvu tam, kde ji chcete mít — uvnitř funkce setup. Položíte ji doprostřed a zapnete pero. Z velké části můžete jednoduše kód překopírovat z jiného úkolu:
  
      p.setup = function() {
        p.createCanvas(size.w, size.h);
        p.angleMode(p.DEGREES);

        turtle = new Turtle(p, size.w/2, size.h/2);
        run = turtle.getRun();
      };

  Proměnné, které budete potřebovat, si mezitím vypíšete na začátek skriptu (též snadno kopírovatelné):

      var turtle, run, size = toy.measure();  
      
  ### Základní algoritmus
  
  Na začátku si můžete sluníčko rozdělit na kolečko a paprsky.
  
      function drawSun() {
        drawSunCircle();
        drawSunbeams();
      }
      
  Napíšete si takto názvy funkcí, které **by měly v budoucnu** něco konkrétního dělat. Funkce si můžete napsat k dodefinování:

      function drawSunCircle() {

      }
      
      function drawSunbeams() {

      }
      
  Kód zatím nic nedělá, ale nehází chyby a stačí už jen doplnit obsah obou funkcí.
      
  ### Implementace funkcí
  
  #### Kolečko
  
  Následně můžete želvě vydefinovat metodu, která nakreslí kolečko. Třeba tím, že želva 360krát popojde a zabočí:
      
      function goAndTurn() {
        turtle.right(1);
        turtle.forward(1);
      };

      function drawSunCircle() {
        repeat(goAndTurn, 360);
      };

  Funkci `repeat()` si opět zkopírujete odjinud — není potřeba vynalézat kolo.
  
  #### Paprsky
  
  Při kreslení paprsků můžete vymyslet několik různých způsobů:
    
  - můžete odjet do středu kružnice a z něj vyjíždět ven a dělat paprsky (střed si můžete dopočítat nebo odhadnout dle výsledků)
  - můžete udělat stejný kruh jako naposledy, ale každách pár cyklů můžete vyjet ven a nakreslit paprsek
  - napadne vás jiné řešení?
  
  Už víte, že paprsků budete kreslit několik, tak si můžete vytvořit opakované volání funkce, která kreslí jednotlivé paprsky (a bude jich třeba třicet) — a tím zase oddělíte jeden kus práce od druhé:
    
      function drawSunbeams() {
        repeat(drawSunbeam, 30);
      }
      
      function drawSunbeam() {

      }
  
  Pořád nevíme, jak bude vypadat paprsek, ale už víme, že jich bude 30 a bude je kreslit funkce `drawSunbeam()` — zbývá ji dodefinovat.

  #### Paprsek

  Víme, že paprsků bude třicet, tak dělíme kruh na třicet částí a každý paprsek želvu otočí ven z kruhu, nakreslí paprsek a vrátí ji zpět na výchozí pozici.
  
      function drawSunbeam() {
        // pero je vypnuté
        turtle.penDown = false;
        
        // kus stejného opakování jako minule
        repeat(goAndTurn, 360/30);
        
        // vzdálení se od kruhu
        turtle.left(90);
        turtle.forward(10);
        
        // kreslení
        turtle.penDown = true;
        turtle.forward(40);
        
        // a návrat
        turtle.penDown = false;
        turtle.back(10 + 40);
        turtle.right(90);
      }
  
  ### Shrnutí
  
  Všimněte si, že nejsložitější je metoda, která tvoří paprsky — a provádíte ji třicetkrát. Kdybyste stejný postup chtěli projít bez funkcí, byl by kód mnohem složitější.
  
  **Toto není jediné správné řešení — jde o jedno z mnoha možných** (na začátku jste mohli sluníčko rozdělit na zcela jiné celky, které by se vykreslily rychleji — ale rychlost nemusí být vždy jediná priorita).
  
  Když máte želvu takto navrženou, můžete snadno najít místa, která chcete upravit: například doplnit do kódu příkazy, které mění barvy pera, aby bylo sluníčko barevné, nebo umožňují snadnou změnu počtu nebo délky paprsků přes proměnnou (předvyplněný kód některé úpravy již obsahuje).
  
  ### Zadání
  
  Napište tímto způsobem vlastní kód, který vykreslí panelák nebo jiný dům s mnoha okny a vchodem (nemusíte pracovat s žádnými parametry funkcí). Postup tvorby sepište do pole pro komentář.
rubrics:
  - checklist: ''
    items:
      - Dům je správně vykreslen. 
      - Kód je logicky strukturovaný do několika funkcí.
      - Postup tvorby je popsán v komentáři.
prefill: |
  var turtle, run, 
    size = toy.measure(),
    beamCount = 30,
    beamSize = 100;

  function drawSun() {
    drawSunCircle();
    drawSunbeams();
  }

  function goAndTurn() {
    turtle.right(1);
    turtle.forward(1);
  }

  function drawSunCircle() {
    repeat(goAndTurn, 360);
  }

  function drawSunbeams() {
    repeat(drawSunbeam, beamCount);
  }

  function drawSunbeam() {
    // pero je vypnuté
    turtle.penDown = false;
    
    // kus stejného opakování jako minule
    repeat(goAndTurn, 360/beamCount);
    
    // vzdálení se od kruhu
    turtle.left(90);
    turtle.forward(10);
    
    // kreslení
    turtle.penDown = true;
    turtle.forward(beamSize);
    
    // a návrat
    turtle.penDown = false;
    turtle.back(10 + beamSize);
    turtle.right(90);
  }

  p.setup = function() {
    p.createCanvas(size.w, size.h);
    p.angleMode(p.DEGREES);

    turtle = new Turtle(p, size.w/2, size.h/2);
    drawSun(beamCount);
    run = turtle.getRun();
  };

  p.draw = function() {
    p.background(200);
    run.print();
  };

  function repeat(fn, n) {
    var a = Array.apply(null, Array(n)).map(
      function (_, i) {return i;}
    ).forEach(fn);
  }
---
bloom: understand
input: javascript
questions: |
  ### Podmínkové výrazy
  
  V úkolech jste se již potkali s podmínkovou konstrukcí `if … else`, která umožňuje měnit chování skriptu na základě proměnných.
  
  Můžete tak například rozhodnout, zda kód prozradí tajnou zprávu, na základě toho, jak se jmenuje ten, kdo jej spouští (uvedený příklad nicméně není příliš bezpečný):
      
      var name = window.prompt('Jak se jmenuješ?');
    
      if (name == 'Honza') {
        window.alert('Tajný kód je „42”.');
      } else {
        window.alert('Neřeknu nic!');
      }

  U `if` vždy následuje závorka s *podmínkovým výrazem*. 
  
  - Pokud je výsledek pravdivý (`true`), blok příkazů se provede, 
  - pokud je výraz nepravdivý (`false`), podmínka nasměruje běh skriptu na větev `else` (pokud existuje) anebo přeskočí podmíněný kód.
  
  Podmínkové výrazy si můžete vyzkoušet v konzoli: stačí do ní napsat například `5 == 10` a vyskočí `false`. Když napíšete `5 < 10`, vyskočí `true`.
  
  Můžete si hrát i s proměnnými — nejprve vložíte číslo do proměnné `var n = 5;` a následně vytvoříte srovnání `n < 10`: vyskočí `true`.
  
  Nejčastěji budete v podmínkových výrazech srovnávat čísla (to se hodí zejména v cyklech) a řetězce (viz příklad výše). Pravdivost můžete ale vyhodnotit i pomocí funkcí a metod — například testováním regulárního výrazu:
    
      var name = window.prompt('Jak se jmenuješ?');
      
      if (/^H/.test(name)) {
        window.alert('Tvoje jméno začíná na H!');
      } else {
        window.alert('Tvoje jméno nezačíná na H :-(');
      }

  ### Logické operátory: spojování podmínek    
  
  Pomocí logických operátorů `&&` (logické „a zároveň“) a `||` (logické „nebo“) můžete skládat více podmínek za sebou. Následující podmínka se splní pouze pokud jste dítě ve věku 1—10 let a je Štědrý den (měsíce jsou číslované od nuly, proto je prosinec pod číslem `11`):
    
      var age = window.prompt('Kolik máš let?');
      var d = new Date();
      
      var isKidAge = age >= 0 && age <= 10;
      var isChristmasEve = d.getDate() == 24 && d.getMonth() == 11;
      
      if (isKidAge && isChristmasEve) {
        doSomethingMagical();
      }
  
  V příkladu si můžete všimnout, že logické hodnoty si můžete ukládat do vhodně pojmenovaných proměnných.
  
  ### Zadání
  
  Napište krátký skript, který obsahuje hádanku — slovní nebo číselnou. Klidně využijte nějakou sbírku hádanek na internetu. 
  
  Pokud uživatel uhádne správné řešení, skript ho nějak odmění (např. milým slovem nebo potvrzením úspěchu). Pokud to uživatel netrefí, skript zareaguje nějakým jiným způsobem.
  
  Pro zisk uživatelského vstupu využijte metodu `window.prompt()`, kterou jste viděli v příkladech výše.
rubrics:
  - checklist: ""
    items:
      - Hádanka funguje a pro výstup používá konzoli nebo metodu window.alert().
      - Hádanka přijímá uživatelský vstup pomocí metody window.prompt().
      - Skript dává za dobré řešení pozitivní zpětnou vazbu.
      - Skript dává za špatné řešení negativní zpětnou vazbu.
---
bloom: apply
input: turtle
questions: |
  ### Odsazování a složené závorky

  Počítač přečte libovolně formátovaný kód, ale pro člověka je při psaní programového kódu je důležité udržet si v něm pořádek. Příkazy je vhodné psát na samostatné řádky, občas se hodí i rozdělení jednoho příkazu na více řádků (např. u funkcí s mnoha parametry).
  
  Ke zpřehlednění delších a složitěji strukturovaných kódů se používá odsazování — například obsah funkce nebo podmínky si odsadíte zleva, aby bylo zřetelné, kde začíná a končí. 

  > **Pozn.:** Ke zpřehlednění kódu se používají též komentáře: nicméně dobrý kód by měl být přehledný i bez komentářů.
  
  Javascript se chová podobně jako HTML: mezery (a též tabulátory a nové řádky) si můžete dát téměř kdekoli, aby pro vás byl kód přehledný. Kód bude fungovat stejně dobře bez mezer i s nimi, ale důležité je, aby byl čitelný.
  
  Odsazení vypadá takto jednoduše:
  
      if (a < 10) {
        doSomething();
      }
      
  Ale pomáhá především tehdy, když je kód vnořený vícekrát.
  
      me.doSomething = function() {
        if (goodDay) {
          me.tryToWork();
        } else {
          repeat(function() {
            me.procrastinate(); 
          }, 24*60*60);
        }
      }
  
  Zde v editoru je nastavené automatické odsazení o dvě mezery. Upravte následující kód tak, aby byl každý příkaz (ukončený středníkem) na samostatném řádku a aby byl kód přehledný.
  
  > Pozn.: Existuje mnoho způsobů, jak to dělat. Například otevírací složené závorky se dle některých norem dávají na nový řádek. Pro účely tohoto úkolu následujte libovolná pravidla, podstatné je aby byl výsledek **konzistentní a přehledný**.
prefill: |
  var turtle, run, size = toy.measure(); var snowFlake = function(preview) { repeat(function(i) { snowFlakePart(-1); if (i == 11 && preview) { turtle.penColor = '#FF0000'; } snowFlakePart(1); turtle.right(360 / 12); }, 12); }; var snowFlakePart = function(mirror) { turtle.forward(20); repeat(function() { turtle.back(40); turtle.left(mirror * 30); turtle.forward(40); }, 12); }; p.setup = function() { p.createCanvas(size.w, size.h); p.angleMode(p.DEGREES); p.background('navy'); turtle = new Turtle(p, size.w / 2 - 50, size.h / 2 - 50); run = turtle.getRun(); turtle.color = 'rgba(255, 255, 255, .2)'; turtle.right(360 / 3); snowFlake(false); run.print(); }; function repeat(fn, n) { var a = Array.apply(null, Array(n)).map( function (_, i) {return i;} ).forEach(fn); }
rubrics:
  - checklist: ''
    items:
      - Kód je naformátován pomocí odsazení.
      - Odsazení je konzistentní napříč celým skriptem.
      - Skript je možné stále spustit a chová se jako původní neformátovaný kód.
---
bloom: apply
input: javascript
questions: |
  ### Spojování řetězců a čísel
  
  Podobně jako při práci v tabulkovém procesoru, potřebujete při psaní skriptů pracovat s čísly a texty. Často chcete spočítat nějakou hodnotu a pak ji oznámit ve srozumitelné zprávě.
  
  Řetězce se v javascriptu spojují pomocí operátoru `+`. 
  
      var text = 'abc' + 'xyz';
      console.log(text); // vypíše do konzole 'abcxyz'
      
  Pokud chceme vypsat čísla, funguje to stejně. Pokud začneme řetězcem, čísla se dále nepřičítají, ale připojují (používá se též slovo „zřetězit“, v angličtině se užívá termín „concatenation“).
  
  Pokud chceme spočítat nějaký výsledek z více čísel (např. čísla sečíst, vynásobit atp.), stačí čísla sepnout do závorky. Takto se nejprve provede obsah závorky a vznikne jediné číslo, které se připojí k řetězci. Tedy např.
  
      var text = 'abc' + 'xyz' + (24 * 3600);
      console.log(text); // vypíše do konzole 'abcxyz86400'
  
  Většinou nepracujeme přímo s literály, ale spojujeme proměnné. Výsledek pak může vypadat takto:
    
      var verb = ' uběhlo ';
      var seconds = 3600;
      var text = 'Dnes' + verb + (24 * seconds) + ' sekund.';
      console.log(text); // vypíše do konzole 'Dnes uběhlo 86400 sekund.'
  
  Zkuste si to níže.
prefill: |
  var rows = 6;
  var columns = 12;
  var text1 = 'V tabulce je ';
  var text2 = ' polí.';
  
  // vytvořte proměnnou text tak,
  // aby se po spuštění objevil text
  // 'V tabulce je 72 polí.'
  // bez použití nových literálů

  var text = ? // doplňte
  
  console.log(text);
rubrics:
  - checklist: ''
    items:
      - Řezetec je správně sestaven.
---
bloom: apply
input: javascript
questions: |
  ### Oznamovatel svátků

  Kód v tomto úkolu je velmi podobný „generátoru emocí“ z minulé lekce. Cílem tohoto úkolu je zažít si práci s parametry funkcí/metod.
  
  ### Parametry
  
  Funkce se zapisují se závorkami na konci, v nichž mohou — a nemusí — být parametry. Ve vzorovém kódu vidíte funkci `announce()`, která nemá žádné parametry. Protože nesahá na žádné vnější proměnné (což je komplexnější téma), tak musí vypsat vždycky to samé: „Za mnoho dní budou Velikonoce.“
  
  Pokud bychom ji chtěli rozšířit, musíme jí přidat parametr. Jeho název se zapíše do závorky a uvnitř funkce je pak dostupný jako proměnná.
  
  Můžeme tak udělat jednoduchou funkci, která do konzole píše výsledky příkladů:
    
      var announce = function(result) {
          console.log('Výsledek je ' + result + '.');
      };
      
      announce(35); // vypíše do konzole "Výsledek je 35."
  
  Parametrů můžeme mít více, např.
  
      var announce = function(result, emotion) {
          console.log('Výsledek je ' + result + '. ' + emotion);
      };
      
      announce(0, 'Hurá!'); // vypíše do konzole "Výsledek je 35. Hurá!"
  
  ### Zadání  
    
  Přepracujte funkci v připraveném kódu tak, aby korektně vypisovala počet dní do Vánoc: přidejte parametry v definici funkce, vložte proměnné do textu a předejte proměnné funkci při volání.
  
  (Výpočet využívá toho, že objekt `Date` se převede při odčítání na milisekundy (uplynuté od 1. ledna 1970). Čísla budou časem záporná a mohou se objevit problémy s letním časem, ale tyto „drobnosti“ zanedbejte.)
prefill: |
  var announceHoliday = function() {
    var dayMilliseconds = 24 * 60 * 60 * 1000;
    var difference = new Date("2018/04/01") - new Date();
    var days = Math.ceil(difference / dayMilliseconds);
    var text = 'Za ' + days + ' dní budou Velikonoce.';
    
    return text;
  };  
  
  var announcement = announceHoliday();
  console.log(announcement);
rubrics:
  - checklist: ''
    items:
      - Oznamovatel hlásí správně počet dní do Vánoc.
      - Funkce je parametrizována a všechny parametry jsou zároveň využity pro tvorbu návratové hodnoty funkce.
---
bloom: create
input: p5
comments: 5
vars:
  rabbitColor:
    - zelenou
    - azurovou
    - bílou
    - burgundskou
    - čokoládově hnědou
    - černou
    - červenou
    - fialovou
    - hnědou
    - indigovou
    - levandulovou
    - lososovou
    - meruňkovou
    - modrou
    - nachovou
    - nebesky modrou
    - okrovou
    - oranžovou
    - purpurovou
    - rajčatovou
    - růžovou
    - šedou
    - tmavě hnědou
    - žlutou
  borderColor:
    - zelený
    - azurový
    - bílý
    - burgundský
    - čokoládově hnědý
    - černý
    - červený
    - fialový
    - hnědý
    - indigový
    - levandulový
    - lososový
    - meruňkový
    - modrý
    - nachový
    - nebesky modrý
    - okrový
    - oranžový
    - purpurový
    - rajčatový
    - růžový
    - šedý
    - tmavě hnědý
    - žlutý
questions: |
  ### Želvy a králíci
  
  Při práci se želvou jsme používali [knihovnu p.turtle](https://jan-martinek.github.io/p.turtle/). Jde o jednu z mnoha dostupných knihoven, které modelují chování želvy, které můžete dávat příkazy.
  
  V následujícím příkladu potkáte místo želvy králíka, kterému nedáváte příkazy, ale můžete ho ovládat přímo (šipkami vlevo a vpravo). Jde o jednoduchou hru: králík nesmí narazit do stěny a do své vlastní stopy. Nejspíše jste se s podobným herním principem už setkali.
  
  V kódu vidíte skutečně celou hru — hra má definovaný stav (to znamená popis toho, jaká je aktuální situace) a způsob, jak v ní dochází ke změnám (vše se odehrává ve funkci `draw()`, kterou hra opakovaně volá — 30krát za sekundu). K některým konceptům se dostaneme níže (především k vektorům), ale můžete si kód projít, zkusit jej měnit a sledovat, co se stane.
  
  > **Pozn.:** Všimněte si klíčového slova `this` — v rámci Javascriptu jde o podstatný koncept, nicméně pro účely tohoto úkolu není až tak podstatné jej pojmout. Pokud vás to zaujalo, najděte si více pomocí vyhledávače.

  ### Zadání úkolu

  Projděte si kód a změňte ho tak,
  
  - aby králík zanechával %rabbitColor% stopu,
  - aby herní pole mělo %borderColor% okraj,
  - aby králík začínal vždy uprostřed herního pole,
  - a aby hra komunikovala česky nebo slovensky.
  
  Úpravy popište do pole pro komentáře.
  
  Následně udělejte screenshot, kde je vidět pěkně zakroucená králíkova stopa s několika zatáčkami a kde máte skóre větší než 2000 bodů. Ten odevzdejte v následující úloze. **Pro dosažení výsledků, které potřebujete pro screenshot, můžete zasahovat do kódu. Nemůžete ale použít nástroje pro úpravu obrázků.**
rubrics:
  - checklist: ''
    items:
      - Barvy jsou správně upraveny.
      - Králík začíná uprostřed pole.
      - Hra komunikuje česky nebo slovensky.
      - Úpravy jsou popsané v komentáři.
prefill: |
  var rabbit, gameOver, score,
    size = toy.measure();

  p.setup = function() { // úvodní nastavení/reset
    rabbit = new Rabbit(
      100, 100, 'red', 
      p.LEFT_ARROW, p.RIGHT_ARROW
    );
    
    score = 0;
    gameOver = false;
    
    p.createCanvas(size.w, size.h);
    p.background(255);
    p.stroke('black');
    p.strokeWeight(2);
    p.rect(1, 1, size.w - 2, size.h - 2);
  };

  p.draw = function() { // překreslení
    if (gameOver) {
    showGameOver();
    } else {
      rabbit.update();
      checkGameOver();
      rabbit.render();
      
      score = score + 1;
      showScore(score);
    }
  };

  p.mouseClicked = function() {
    p.setup(); //restart
  };

  function Rabbit(x, y, color, left, right) {
    this.x = x;
    this.y = y;
    
    var dir = new p.createVector(1, 0);
    var speed = 3; 
    var steering = 1;

    this.update = function() {
      this.steer();
      this.move();
    };
    
    this.steer = function(s) {
      if (p.keyIsDown(left)) 
         dir.rotate(steering * -0.1);
      if (p.keyIsDown(right))
         dir.rotate(steering * 0.1);
    };
    
    this.move = function() {
      this.x = this.x + speed * dir.x;
      this.y = this.y + speed * dir.y;
    };  
      
    this.render = function() {
      p.stroke(color);
      p.strokeWeight(speed);
      p.line(
        this.x, this.y, 
        this.x - speed * dir.x, 
        this.y - speed * dir.y
      );  
    };  
  }

  function checkGameOver() {
    // získá barvu pixelu, kde je zrovna želva
    var bg = p.get(
      Math.round(rabbit.x),
      Math.round(rabbit.y)
    );
    
    // pokud barva není bílá, hra končí
    if (bg[0]+bg[1]+bg[2] != 3*255) {
      gameOver = true;
    }
  }

  function showGameOver() {
    var pos = {
      x: p.random(-150, size.w),
      y: p.random(-150, size.h)
    };
    
    p.noStroke();
    p.fill('red');
   
    p.text('game over, click to play', pos.x, pos.y);
  }

  function showScore(score) {
    p.fill('lightgray');
    p.noStroke();
    p.rect(2, 2, 110, 30);
    
    p.fill('black');
    p.text('score: ' + score, 10, 20);
  }
---
bloom: create
input: file
comments: 3
questions: |
  Zde vložte otisk obrazovky z předchozí úlohy. Do komentáře popište, jak jste dosáhli požadovaného bodového zisku.
rubrics:
  - checklist: ''
    items:
      - Zobrazené skóre je větší než 2000 bodů.
      - Screenshot barevně odpovídá upraveným barvám v předchozím úkolu.
      - V komentáři je popsáno, jak autor/ka dosáhl/a požadovaného skóre.
---
bloom: apply
input: p5
comments: 10
questions: |
  ### Proč se učit skriptovat?
  
  Kreslení tvarů se želvou a geometrické a slovní hříčky jsou jen začátek: Javascript umožňuje tvorbu libovolné aplikace. Principiálně jde stále o podobné úlohy — **příjem vstupů, transformace dat funkcemi a zobrazování výsledků**. Výhodou Javascriptu je to, že nevyžaduje složité vývojové prostředí, protože si výsledné skripty můžeme spustit přímo v internetovém prohlížeči.
  
  Javascript umožňuje vyřešit úlohy, které jsme řešili v jiných lekcích — využijete regulární výrazy a můžete pracovat s tabulkovými daty i složitěji strukturovanými daty (např. vytaženými z databáze).

  **Někdy je jednodušší použít připravený nástroj, který je efektivní v řešení určité sady problémů** (jako např. tabulkový procesor), **jindy se může hodit flexibilita vlastního řešení**. Občas může být užitečné naprogramovat si vlastní kalkulačku nebo tabulkový procesor — anebo (častěji) najít na webu otevřenou implementaci a nějak si ji pro vlastní potřebu upravit.
  
  V Javascriptu jsou napsány i velké aplikace, které nejspíše často používáte — např. e-mailové klienty (Gmail, Seznam apod.), kancelářské aplikace (např. Google Documents, Google Spreadsheets). 
  
  Krom Javascriptu potřebujete pro tvorbu aplikací ještě znalost HTML a stylopisů CSS (ty jsou zařazeny ve výuce jarního kurzu VIKBA07). Pro některé úlohy se obejdete i bez těchto dvou jazyků — např. při tvorbě vizualizací nebo her můžete využít knihovnu [p5.js](https://p5js.org), kterou jsme využívali v tomto kurzu.
  

  #### Algoritmizace
  
  Konkrétní jazyky však nejsou tou nejdůležitější dovedností. **Tou je schopnost sestavit zadání pro počítač — tedy tvorba algoritmů.** Čtyři lekce tohoto kurzu jsou v této oblasti jen náznakem: nicméně byste si nyní měli být schopni představit, co taková činnost zahrnuje (od definice algoritmu, po jeho vývoj a vyzkoušení) a jaké výhody přináší užití počítačů (např. možnost opakovaně zkoušet, jestli „to funguje“ a průběžně odchytávat chyby).
  
  Pokud vás to zaujalo, můžete pokračovat čtením [článků na Wikipedii](https://en.wikipedia.org/wiki/Algorithm_design) a následně i odkazovaných zdrojů. Většina postupů v tomto kurzu (učení želvy, definice funkcí apod.) odpovídá metodikám „[rozděl a panuj](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms)“. 
  
  Nenechte se odradit občasným matematickým jazykem — většinou stačí přeskočit úvodní kondenzovanou větu či odstavec. Mnoho zdrojů je napsáno přístupně (např. *[The Algorithm Design Manual](http://www.algorist.com)* od Stevena Skieny).


  #### Vnořené pole: vícerozměrná data

  Teď se vrátíme k poli — datové struktuře, která obsahuje seřazené hodnoty (všimněte si podobnosti s řetězcem: místo písmen seřazených za sebou jde jen o rozmanitější hodnoty). Seřazené hodnoty se dají využít v algoritmu, který je nějak přelouská — najde v nich buď data nebo příkazy. 

  Velmi jednoduché želví skripty bychom mohli zapsat pomocí pole a následně pomocí skriptu takový zápis načíst a provést. Konvence mohou být různé — můžeme střídat příkaz a hodnotu anebo je poskládat do menších polí po dvojicích:

      var run = ['forward', 30, 'right', 90, 'color', 'red',  'back', 10];
      var run2 = [['forward', 30], ['right', 90], ['color', 'red'], ['back', 10]];

  Pole se dá využít mnoha různými způsoby, jedním z nich je ukládání tabulkových dat. Příklad najdete v připraveném kódu. 

  Přečtěte si kód (nejlépe s pomocí tipů z úkolů výše) a popište *podrobně* vlastními slovy do pole pro komentář, jak pracuje předvyplněný skript. Vykreslování používá knihovnu [p5.js](https://p5js.org), jejíž dokumentaci najdete [zde](https://p5js.org/reference/) — zde budete potřebovat znát především roli funkce `setup()` a předpis funkce `text()` (s oběma jsme se potkali již dříve).
  
  **Následně pozměňte kód tak, aby byl zvýrazněný první a poslední sloupec a také první a poslední řádek.** Využijte k tomu podmínky. Pro zvýraznění použijte nastavení výplňové barvy (metoda [`p.fill()`](https://p5js.org/reference/#/p5/fill)).
  
  > **Pozn.:** Tabulka záměrně nemá vykreslené okraje buněk pro zjednodušení skriptu.
  
  > **Pozn.:** Pro zjištění, zda proměnná existuje a obsahuje nenulovou hodnotu, můžeme použít krátkou konstrukci `if (názevProměnné) { … }`. Toto má ovšem nevýhodu: pokud bude proměnná obsahovat nulu nebo prázdný řetězec, vyhodnotí se podmínkový výraz jako `false` — a to občas nemusíme chtít. Stejně tak je problém, pokud bychom chtěli ověřit existenci prvku ve vícerozměrném poli, např. `arr[1][2]`: když nebude definována ani hodnota `arr[1]`, skončí běh skriptu chybou, protože nemá kde hledat vnořenou hodnotu.
rubrics:
  - checklist: ''
    items:
      - Skript je podrobně popsaný.
      - Požadované sloupce a řádky zvýrazněné.
prefill: |
  var size = toy.measure();

  var head = [' ', 1, 2, 3, 4];
  var row1 = ['Pavel', 3, 4, 7, 6, 20];
  var row2 = ['Martina', 4, 5, 1, 4, 14];

  var table = [
    head, 
    row1, 
    row2,
    ['Petr', 4, 2, 1, 2, 9],
    ['Celkem', 11, 11, 9, 12, 43]
  ];


  p.setup = function() {
    p.createCanvas(size.w, size.h);
    drawTable();
  };

  function drawTable() {
    p.fill('black');

    var margin = 50;
    var colWidth = 70;
    var rowHeight = 30;
    
    repeat(function(row) {
      repeat(function(column) {
        var x = margin + column * colWidth;
        var y = margin + row * rowHeight;

        p.text(table[row][column], x, y);
      }, table[row].length);
    }, table.length);
  }

  function repeat(fn, n) {
    var a = Array.apply(null, Array(n)).map(
      function (_, i) {return i;}
    ).forEach(fn);
  }
---
bloom: understand
input: javascript
comments: 5
questions: |
  V předcházející úloze jsme procházeli jednotlivými hodnotami pole. Procházet můžeme i vlastnostmi objektu.
  
  Popište **na základě pozorování** jak pracuje cyklus `for … in` — jde o jiný způsob, jak docílit opakování v kódu.
  
  K pozorování použijte zapisování hodnot do konzole (`console.log()`) a popište, jak jste postupovali.
rubrics:
  - checklist: ''
    items:
      - Cyklus `for … in` je správně popsaný (včetně postupu, kterým bylo jeho chování odpozorováno).
      - Kód obsahuje několik volání `console.log()`, která zachycují stav skriptu.
prefill: |
  var marketPrices = {
    cetin: 170.20,
    cetvCme: 54.20,
    cez: 479.60,
    ersteGoupBank: 728.50,
    fortuna: 73.00,
    komercniBanka: 5193.00,
    nwr: 0.18,
    o2Cr: 229.10,
    pegasNonwovens: 763.60,
    philipMorrisCr: 11636.00,
    plgLobkowicz: 204.90,
    unipetrol: 141.1,
    vig: 798.80
  };

  var portfolio = {
    fortuna: 110,
    komercniBanka: 160,
    cez: 330,
    unipetrol: 20,
  };

  function calcPortfolioPrice() {
    var sum = 0;
    
    for (var stock in portfolio) {
      sum = sum + (marketPrices[stock] * portfolio[stock]);
    }
    
    return sum;
  }    

  console.log('Celkem: ' + calcPortfolioPrice());
---
bloom: understand
input: javascript
questions: |
  Vytvořte na začátku skriptu objekty popisující zvířátka tak, aby o nich skript mohl vytvářet věty. (Inspirujte se objekty v předchozí úloze.) Skript vybírá z pole náhodné zvířátko a generuje věty z definovaných vlastností.
  
  **Příklad:** *„Prasátko je roztomilé a má celkem 4 končetin.“*
  
  Pokud chcete, můžete popis zvířátka rozšířit o další vlastnosti.
rubrics:
  - checklist: ''
    items:
      - Objekty jsou správně vytvořeny.
prefill: |
  // zde doplňte definici objektů



  /**************************************
   *                                    *
   * úpravy ve zbytku kódu nejsou nutné *
   *                                    *
   **************************************/

  var animals = [piglet, rabbit, tiger, snake];

  // generátor celých čísel od 0 do 3
  var num = Math.ceil(Math.random() * 4) - 1;

  var animal = animals[num];
  var statement = animal.name + 
    ' je ' + animal.characteristic +
    ' a má celkem ' + (animal.limbs * 2) + ' končetin.';

  console.log(num, statement);
---
bloom: apply
input: javascript
questions: |
  Doplňte skript tak, aby proměnná `totals` obsahovala před závěrečným výpisem součty sloupců definovaných v poli. (Zamyslete se, co jsou to v poli „sloupce“.)
  
  Skript obsahuje náhodně vygenerované číslo `r` — proto není možné součet určit předem, ale musí být vždy spočteno. Žádnou hodnotu nevkládejte literálem, vše spočítejte přímo pomocí hodnot dostupných v poli `numbers`. 

  V ideálním případě využijte opakování pomocí funkce `repeat()`, kterou si zkopírujte odjinud.
rubrics:
  - checklist: ''
    items:
      - Výsledek obsahuje správné součty.
      - Sčítání je vytvořeno dle zadání (vyhovuje všem nutným podmínkám).
      - Pro zjednodušení je využito opakování pomocí funkce repeat().
prefill: |
  var r = Math.round(Math.random()*9);
  
  var numbers = [
    [r, 4, 2, 4, 9],
    [4, 8, 5, r, 3],
    [9, 1, r, 4, 2],
    [4, r, 4, 5, r],
    [0, 1, 4, 3, 1],
    [7, 1, 2, 9, 2]
  ];

  var totals = [0, 0, 0, 0, 0];

  // doplňte sčítání zde

  console.log(r, totals);
---
bloom: apply
comments: 5
input: turtle
vars:
  chart:
      - koláčový graf
      - sloupcový graf
  array:
      - "[34, 21, 45]"
      - "[12, 56, 32]"
      - "[80, 9, 11]"
      - "[51, 22, 22, 5]"
      - "[22, 25, 34, 19]"
questions: |
  Nakreslete pomocí želvy **%chart%**, který znázorňuje hodnoty udané v poli `%array%`. Cílem není nakreslit podrobný graf — nemusíte kreslit osy, popisovat hodnoty nebo vybarvovat plochy — stačí, aby 
  
  - připomínal daný typ grafu, 
  - vyplňoval užitečně prostor daný bílým obdélníkem, který želva kreslí na začátku, 
  - a **správně vyjadřoval zadané číselné hodnoty**.
  
  Algoritmus pro kreslení grafu nejprve popište do pole pro komentář. Pokud si nejste jisti algoritmem, zeptejte se klidně v diskusním fóru, zda je vaše řešení správné. Vykreslování grafu popište alespoň dvěma funkcemi.
  
  V předvyplněném kódu vidíte příklad vykreslení bodového grafu pro dlouhou číselnou řadu. (Zadaný %chart% můžete vykreslit i jednodušším kódem.)
  
  > **Tipy:** Želvu si na začátku výhodně umístěte pomocí volání nastavení proměnné `turtlePos`. Kreslení bílého obdélníku můžete vypnout nastavením proměnné `showBoundaries`. Stejně tak můžete zapnout okamžité vykreslení výsledku pomocí proměnné `printAtOnce`. (Podívejte se pro zajímavost, jak jsou použity zmíněné proměnné níže v kódu.)
rubrics:
  - checklist: ''
    items:
      - Algoritmus je správně popsaný v pole pro komentáře.
      - Graf je správně vykreslený a pracuje se správnými daty.
prefill: |
  var turtle, run, 
    size = toy.measure(),
    printAtOnce = false,
    showBoundaries = true,
    turtlePos = { x: 20, y: 340 };

  // datová sada
  var values = [0, 2, 5, 6, 7, 7, 8, 9, 10, 12, 14, 15, 16, 16, 17, 17, 18, 19, 20, 21, 22, 23, 24, 23, 22, 21, 20, 22, 23, 22, 24, 26, 26, 27, 29, 29, 30, 30, 32, 33, 34, 35, 35, 36, 37, 38, 39, 39, 39, 40, 41, 43, 43, 44, 45, 46, 48, 49, 5, 5, 7, 9, 10, 50, 50, 50, 51, 52, 53, 53, 57, 60, 61, 62, 62, 64, 65, 66, 67, 67, 67, 68, 69, 70, 70, 70];

  // základní algoritmus
  function drawChart(data) {
    var gap = 430/data.length, unit = 3;
    
    var drawSegment = function(i) {
      drawDataPoint(data[i], unit, gap);
      moveOn(gap);
    };

    repeat(drawSegment, data.length);
  }

  // kreslení datové hodnoty
  function drawDataPoint(n, unit, gap) {
    turtle.forward(unit * n);
    drawTinyCircle();
    turtle.back(unit * n); 
  }

  // kreslení grafického symbolu
  function drawTinyCircle() {
    turtle.penDown = true;
    repeat(function() {
      turtle.forward(2);
      turtle.right(40);
    }, 360/40);
    turtle.penDown = false;
  }

  // posun k dalšímu bodu
  function moveOn(gap) {
    turtle.right(90);
    turtle.forward(gap);
    turtle.left(90);
  }


  /**************************************
   *                                    *
   * úpravy ve zbytku kódu nejsou nutné *
   *                                    *
   **************************************/
  p.setup = function() {
    p.createCanvas(size.w, size.h);
    p.angleMode(p.DEGREES);
    turtle = new Turtle(p, turtlePos.x, turtlePos.y);
    
    if (showBoundaries) {
      drawBoundaries();
    }

    drawChart(values);
    
    run = turtle.getRun();

    if (printAtOnce) {
      run.print(10);
    }
  };

  p.draw = function() {
    if (printAtOnce == false) {
      p.background(200);
      run.animate(10);
    }
  };

  function drawBoundaries() {
    turtle.penDown = true;
    turtle.color = 'white';
    
    var boundaries = [320, 430, 320, 430];
    for (var i = 0; i < boundaries.length; i++) {
      turtle.forward(boundaries[i]);
      turtle.right(90);
    }
    
    turtle.penDown = false; 
    turtle.color = 'black';
  }

  function repeat(fn, n) {
    var a = Array.apply(null, Array(n)).map(
      function (_, i) {return i;}
    ).forEach(fn);
  }
---
bloom: create
input: p5
questions: |
  ### Kreslení myší
  
  Předvyplněný kód obsahuje velmi jednoduchý nástroj na kreslení. Doplňte kód tak, aby bylo možné pomocí kliku pravým tlačítkem myši (či touchpadu) opakovaně měnit barvu „štětce“ (všimněte si, jak se barva nastavuje v úvodu skriptu).
  
  Pro zachycení pravého kliknutí se nehodí funkce `draw()`, protože stihne i během krátkého kliknutí proběhnout několikrát (volá se 30x za sekundu). Využijte tedy možnost definovat funkci `mouseClicked()`, která se volá pouze tehdy, když dojde k jednotlivému kliknutí a pomocí podmínky odchyťte kliknutí pravým tlačítkem. Detaily hledejte v dokumentaci [p5.js](https://p5js.org/reference/) (hledejte vlastnosti a metody obsahující `mouse`).
  
  > **Tip:** Některé barvy můžete nastavovat pomocí klíčových slov (např. `red`, `blue`, `magenta`), ale můžete využít i další zápisy, na které jsme narazili: hexadecimální zápis RGB (`#FF0000`), decimální zápis RGB (`rgb(255, 0, 0)`) nebo decimální zápis HSL (`hsl(0, 100%, 50%)`). (Všechny příklady v závorkách popisují stejnou červenou barvu.)
  >
  > Zajímavé může být přidání průhlednosti pomocí zápisů RGBA nebo HSLA (`rgba(255, 0, 0, 0.5)`, resp. `hsla(0, 100%, 50%, 0.5)`, které umožní míchání barev na plátně. Poměrně jednoduché je pak i vytvoření „kapátka“, kterým můžete barvu nastavit pomocí kliknutí do plátna — stačí využít metodu `get()`.
rubrics:
  - checklist: ''
    items:
      - Klikem pravým tlačítkem myši (či touchpadu) je možné měnit barvu štětce.
prefill: |
  var size = toy.measure(), brushColor = 'black';

  p.setup = function() {
    p.createCanvas(size.w, size.h);
    
    p.fill(brushColor);
    p.noStroke();
  };

  p.draw = function() {
    if (p.mouseIsPressed) {
      p.ellipse(p.mouseX, p.mouseY, 20);  
    }
  };

  p.mouseClicked = function() {
    
  };
---
bloom: create
input: p5
comments: 10
questions: |
  ### Zrcadlení
  
  Kód je velmi podobný jako v příkladu výše — jen kreslí na dvou místech zároveň.
  
  Popište, jak kód funguje. Následně změňte *osu souměrnosti* a popište, jak jste to udělali.
rubrics:
  - checklist: ''
    items:
      - Logika kreslení je popsaná v poli pro komentáře.
      - Je popsáno, jak změnit osu souměrnosti.
      - Osa souměrnosti je ve skriptu upravena.
prefill: |
  var size = toy.measure();

  p.setup = function() {
    p.createCanvas(size.w, size.h);
    p.fill('black');
    p.noStroke();
  };

  p.draw = function() {
    if (p.mouseIsPressed) {
      p.ellipse(p.mouseX, p.mouseY, 20);  
      p.ellipse(size.w - p.mouseX, p.mouseY, 20);
    }
  };
---
bloom: apply
input: p5
questions: |
  ### Vektory
  
  Následující kód představuje koncept vektoru — jde o matematický koncept, který dvěma a více čísly (souřadnicemi *x*, *y*, *z*…) označuje velikost a směr. Běžné číslo (*skalár*) má pouze velikost.
  
  > **Pozn.:** Při práci se želvou je práce s vektorem schována do dvou různých operací: funkce `left()` a `rigt()` mění směr (interně uchovaný ve vektoru nenulové délky), funkce `forward()` a `back()` jednorázově nastaví velikost vektoru a želvu posunou.
  
  My budeme používat pouze dvourozměrné vektory, ale práce s vícerozměným prostorem již není o mnoho složitější. Tu nepříjemnou část (*počítání*) za vás obstará *počítač* a tak může být práce s vektory poměrně zábavná.
  
  Vektory jsou v podstatě souřadnice, s nimiž ale můžeme příjemně pracovat: můžeme je sčítat a odčítat, násobit (skalárem i jiným vektorem) a dělit. Výsledky se „spočítají samy“, tak je jednoduché vyzkoušet, jaké výsledky jednotlivé operace přinášejí.
  
  ### Vektorové operace
  
  Sčítání vektorů je jednoduché — stačí souřadnice sečíst:
  
      var v1 = p.createVector(10, 10);
      var v2 = p.createVector(5, -5);
      var sumVector = p.createVector(v1.x + v2.x, v1.y + v2.y);
      
  Nicméně díky dostupným funkcím je možné poslední řádek zapsat jednodušeji (`v1` je neprve zkopírován — jinak by se sčítání promítlo přímo do něj):
  
      var sumVector = v1.copy().add(v1, v2);
  
  Když chceme vektor změnit, můžeme používat další metody — např. pro jeho natočení nebo změnu jeho velikosti:
    
      var vector = p.createVector(10, 10);
      vector.mult(2); // násobení skalárem — výsledek je dvakrát delší vektor
      vector.rotate(90); // otočení o 90 stupňů po směru hodinových ručiček
  
  ### Předvyplněný příklad
  
  Předvyplněný kód používá dva vektory — ve funkci `setup()` jsou do vektoru `center` vloženy souřadnice středu kreslícího pole a druhý, nazvaný `vector`, je nastaven na hodnotu, kterou jsem si vymyslel. (Dalo by se též říct, že je nastaven na arbitrární hodnotu vhodnou pro předváděcí účely.)
  
  Během opakovaně volané funkce `draw()` je kresleno kolečko na souřadnice dané součtem obou vektorů. Kód na řádcích 13—14 by tedy bylo možné přepsat také takto:
  
      p.ellipse(center.x + vector.x, center.y + vector.y, 5);
      
  Vektor se po nakreslení kolečka o něco otočí a zvětší (vynásobí číslem, které je větší než 1), viz řádky 16–17. Díky tomu, že se funkce `draw()` opakuje mnohokrát, je i zvětšení o tisícinu aktuální velikosti rychle a snadno patrné.
  
  ### Zadání
  
  Prozkoumejte daný kód a vytvořte odlišnou animaci na stejném principu:
  
  - Použijte nějaké [jiné vektorové funkce](https://p5js.org/reference/#/p5.Vector) (oddíl *Methods*), které nejsou v předvyplněném kódu užité (klidně přidejte nějaký další vektor). 
  - Použijte jinou kreslící funkci — namísto kruhu můžete kreslit například obdélníky, trojúhelníky nebo čáry (viz [reference](https://p5js.org/reference/), oddíl `Shape`). 
  - Použijte barvy, které jsou odvozeny z nějaké dostupné proměnné (např. z některé souřadnice či jejich součtů).
  
  > **Pozn.:** [čára](https://p5js.org/reference/#/p5/line) je spojnice dvou bodů, tzn. dvou sad souřadnic, tzn. dvou vektorů.
  
  > **Tip:** Výplň nastavíte funkcí `fill()`, barvu čáry nebo obrysu pomocí `stroke()`. Pokud chcete tvar bez výplně nebo obrysové čáry, použijte funkci `noFill()`, resp. `noStroke()`.
rubrics:
  - checklist: ''
    items:
      - Animace je odlišná od původního příkladu.
      - Jsou využity jiné vektorové funkce.
      - Jsou využity jiné funkce pro kreslení tvarů.
      - Výsledek je vykreslen několika různými odstíny barev.
prefill: |
  var size = toy.measure();
  var center;
  var vector;

  p.setup = function() {
    p.createCanvas(size.w, size.h);
    p.angleMode(p.DEGREES);
    center = p.createVector(size.w/2, size.h/2);
    vector = p.createVector(30, 30);
  };

  p.draw = function() {
    var position = center.copy().add(vector);
    p.ellipse(position.x, position.y, 5);
    
    vector.rotate(8.1); // otáčení vektoru
    vector.mult(1.001); // násobení vektoru
  };
---
bloom: create
input: p5
questions: |
  ### Generátor mandal

  Kód je opět velmi podobný tomu, s nímž jsme se potkali výše při kreslení (úlohy 6 a 7). Tentokrát je však pozice myši před samotným kreslením převedená na vektor, který je vztažený ke středu kreslícího plátna.
 
  **Vícenásobnou rotací tohoto vektoru** napodobte fungování aplikace [Amaziograph](http://www.amaziograph.com), která umožňuje vícenásobně symetrické kreslení — pro příklad se [podívejte na videa](https://www.youtube.com/results?search_query=amaziograph). Výsledkem jsou tvary, které mohou připomínat [mandaly](https://en.wikipedia.org/wiki/Mandala).
  
  Krom rotace upravte některé vlastnosti skriptu, aby byl výsledek vizuálně pestřejší. Pro inspiraci několik příkladů možného odlišení:
  
  - Namísto kreslení kolečka můžete kreslit jiné útvary.
  - Použijte ke kreslení různé barvy (mohou se měnit podle rotace nebo v závislosti na velikosti vektoru).
  - Použijte část skriptu, který jste vytvořili výše a umožňete přepínání barev pomocí pravého tlačítka myši.
  - Uložte si bokem staré souřadnice a pak je použijte pro nakreslení spojnice s aktuálním vektorem. (Pozor: proměnné si vydefinujte na začátku skriptu, jinak nebudou uložené hodnoty dostupné při dalším volání funkce `draw()` — pro více informací o googlujte „[javascript scope](https://www.google.cz/search?q=javascript+scope)“ nebo „[javascript viditelnost proměnných](https://www.google.cz/search?q=javascript+viditelnost+prom%C4%9Bnn%C3%BDch)“.)
  
  > **Tip:** Vytvořené mandaly neukládejte a přijměte pomíjivost světa. Kód generátoru nicméně uložte, abyste nepřišli o body.
rubrics:
  - checklist: ''
    items:
      - Generátor funguje dle zadání.
      - V samotné kresbě jsou alespoň dvě úpravy (barvy, tvar, jiné možnosti interakce atp.).
prefill: |
  var size = toy.measure();
  var center;

  p.setup = function() {
    p.createCanvas(size.w, size.h);
    p.angleMode(p.DEGREES);
    center = p.createVector(size.w/2, size.h/2);
  };

  p.draw = function() {
    if (p.mouseIsPressed) {
      var fromCenter = p.createVector(
        center.x - p.mouseX, 
        center.y - p.mouseY
      );

      p.ellipse(
        center.x - fromCenter.x, 
        center.y - fromCenter.y, 
        10
      );  
    }
  };
